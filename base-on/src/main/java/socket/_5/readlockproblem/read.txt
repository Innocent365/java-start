服务端和客户端都在接收数据时阻塞:

问题的引出:

    1.客户端与服务器端在接收和发送数据时，read()和write()方法不一定对应，
        比如，其中一方可以一次发送多个字节的数据，而另一方可以一个字节一个字节地接收，
        也可以一个字节一个字节地方送，而多个字节多个字节地接收。

        因为TCP协议会将数据分成多个块进行发送，而后在另一端会从多个块进行接收，
        再组合在一起，它并不仅能确定read()和write()方法中所发送信息的界限。

    2.read()方法会在没有数据可读时发生阻塞，直到有新的数据可读。

问题的解决
    问题就出现在 read()方法上，这里的重点是 read()方法何时返回-1，
    在一般的文件读取中，这代表流的结束，亦即读取到了文件的末尾，
    但是在 Socket 套接字中，这样的概念很模糊，因为套接字中数据的末尾并没有所谓的结束标记，
    无法通过其自身表示传输的数据已经结束，那么究竟什么时候 read()会返回 -1 呢？

    答案是：当 TCP 通信连接的一方关闭了套接字时。

    再次分析改过后的代码，客户端用到了read()返回 -1 这个条件，而服务端也用到了，
    只有二者有一方关闭了 Socket，另一方的 read()方法才会返回 -1，
    而在客户端打印输出前，二者都没有关闭 Socket，
    因此，二者的 read()方法都不会返回 -1，程序便阻塞在此处，都不往下执行，这便造成了死锁。

    如果在客户端不知道反馈回来的数据的情况下，该如何避免死锁呢？
        Java 的 Socket 类提供了 shutdownOutput()和 shutdownInput()另个方法，
        用来分别只关闭 Socket 的输出流和输入流，而不影响其对应的输入流和输出流，
        那么我们便可以在客户端发送完数据后，调用 shutdownOutput()方法将套接字的输出流关闭，
        这样，服务端的 read()方法便会返回 -1，继续往下执行，
        最后关闭服务端的套接字，而后客户端的 read()()方法也会返回 -1，继续往下执行，直到关闭套接字。
     告知对方：“我已经发送完所有数据” ，同时我保持有接收数据的能力。


        调用Socket.shutdownInput( )后， 禁用此套接字的输入流，
            发送到套接字的输入流端的任何数据都将被确认然后被静默丢弃。
            任何想从该套接字的输入流读取数据的操作都将返回-1；

        调用Socket.shutdownOutput()后，禁用此套接字的输出流，
            对于 TCP 套接字，任何以前写入的数据都将被发送，
            并且后跟 TCP 的正常连接终止序列（即-1），之后，从另一端TCP

        套接字的输入流中读取数据时，如果到达输入流末尾而不再有数据可用，则返回 -1。
        注意：
           当调用Socket.shutdownInput( )后，还能够往该套接字中写数据（执行OutputStream.write( )）；
           当调用Socket.shutdownOutput( )后，还能够往该套接字中读数据（执行InputStream.read( )）；


https://blog.csdn.net/dabing69221/article/details/17351881
