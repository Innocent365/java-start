
首先Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件，
加载完毕之后，交由JVM执行引擎执行。

在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。
因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。

运行时数据区(JVM内存)通常包括这几个部分：
    程序计数器(Program Counter Register)、

    Java栈(VM Stack)、
    本地方法栈(Native Method Stack)、


    堆(Heap)、

    方法区(Method Area)

1.方法区, 又称为永久代（Perm Generation）:                 permanent adj. 永久的，永恒的；不变的
    存储了每个类的元数据信息 （包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。
    在方法区中有一个非常重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。
    当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。
    在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，
    常见的JVM配置包括： -XX:MaxPermSize=512m
        JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。
        有时候会看到java进程报一个错误类似: Exception in thread "State Saver" java.lang.OutOfMemoryError: PermGen space
            说代码中有一些bug导致大量的perm区被占用，可能是用到了太多的静态变量（一般怀疑map）或者说用到ASM框架导致产生了大量的类信息。

2.堆(heap)：
    Java中的堆是用来存储对象实例的以及数组（当然，数组引用是存放在Java栈中的）。
    这部分空间也是Java垃圾收集器管理的主要区域。另外，堆是被所有线程共享的，在JVM中只有一个堆。
        堆 = Old Space + Young Space
            Old Space主要存放应用程序中生命周期长的存活对象；


    JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4。
    默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。
    因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。

3.Java栈:    栈帧=局域变量区+操作数区+帧数据区
    Java栈也称作虚拟机栈（Java Virtual Machine Stack），也就是我们常常所说的栈，跟C语言的数据段中的栈类似。事实上，Java栈是Java方法执行的内存模型。
    Java栈中存放的是一个个的栈帧（Stack Frame），每个栈帧对应一个被调用的方法，在栈帧中包括
        局部变量表(Local Variables)、     //存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。对于基本数据类型变量直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。
                                        //局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。
        操作数栈(Operand Stack)、        //程序中的所有计算过程都是在借助于操作数栈来完成的。
        指向当前方法所属的类的 运行时常量池（见方法区）的引用(Reference to runtime constant pool)、
        方法返回地址(Return Address)和一些额外的附加信息。           //当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。

    当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。这部分空间的分配和释放都是由系统自动实施的。
    每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。


    栈的大小：   JVM栈=栈帧+栈帧+...
        可以受到几个因素影响，一个是jvm参数 -XSS，默认值随着虚拟机版本以及操作系统影响，可以认为64位linux默认是1m的样子。
        除了JVM设置，我们还可以在创建Thread的时候手工指定大小：public Thread(ThreadGroup group, Runnable target, String name , long stackSize)

        栈的大小影响到了线程的最大数量，第一个限制在操作系统，
        第二个限制自然是在JVM，理论上我们能分配给线程的内存除以单个线程占用的内存就是最大线程数。所以说对Java进程来讲，既然分配给了堆，栈和静态方法区（或叫永久代，perm区），我们可以大致认为

        线程数 = （系统空闲内存 - 堆内存（-Xms, -Xmx）- perm区内存(-XX:MaxPermSize)) / 线程栈大小(-Xss)

    如何查看线程栈：使用命令 jstack <pid>可以列出当前pid对应jvm的所有线程栈描述，描述主要包括了每个线程的状态以及堆栈内各栈帧的方法全限定名，代码位置。

4.本地方法栈：
    Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。
    在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。

5.程序计数器(Program Counter Register)，也有称作为PC寄存器:
    在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），
    当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。

    虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示 执行哪条指令的。

    由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，
    因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。
    因此，可以这么说，程序计数器是每个线程所私有的。

    在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。
　　由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。



JVM运行时内存 = 共享内存区 + 线程内存区
            共享内存区 = 持久带 + 堆
                        持久带 = 方法区 + 其他
                                堆 = Old Space + Young Space

其他理解：
1）栈是为执行线程留出的内存空间。当函数被调用的时候，栈顶为局部变量和一些 bookkeeping 数据预留块。当函数执行完毕，块就没有用了，可能在下次的函数调用的时候再被使用。栈通常用后进先出（LIFO）的方式预留空间；因此最近的保留块（reserved block）通常最先被释放。这么做可以使跟踪堆栈变的简单；从栈中释放块（free block）只不过是指针的偏移而已。
    堆（heap）是为动态分配预留的内存空间。和栈不一样，从堆上分配和重新分配块没有固定模式；你可以在任何时候分配和释放它。这样使得跟踪哪部分堆已经被分配和被释放变的异常复杂；有许多定制的堆分配策略用来为不同的使用模式下调整堆的性能。

    每一个线程都有一个栈，但是每一个应用程序通常都只有一个堆（尽管为不同类型分配内存使用多个堆的情况也是有的）。

     1. 当线程创建的时候，操作系统（OS）为每一个系统级（system-level）的线程分配栈。通常情况下，操作系统通过调用语言的运行时（runtime）去为应用程序分配堆。
     2. 栈附属于线程，因此当线程结束时栈被回收。堆通常通过运行时在应用程序启动时被分配，当应用程序（进程）退出时被回收。
     3. 当线程被创建的时候，设置栈的大小。在应用程序启动的时候，设置堆的大小，但是可以在需要的时候扩展（分配器向操作系统申请更多的内存）。
     4. 栈比堆要快，因为它存取模式使它可以轻松的分配和重新分配内存（指针/整型只是进行简单的递增或者递减运算），然而堆在分配和释放的时候有更多的复杂的 bookkeeping 参与。
        另外，在栈上的每个字节频繁的被复用也就意味着它可能映射到处理器缓存中，所以很快（译者注：局部性原理）。


2）
    1.一样存储在计算机 RAM 中。
    Stack:
          在栈上创建变量的时候会扩展，并且会自动回收。
          相比堆而言在栈上分配要快的多。
          用数据结构中的栈实现。
          存储局部数据，返回地址，用做参数传递。
          当用栈过多时可导致栈溢出（无穷次（大量的）的递归调用，或者大量的内存分配）。
          在栈上的数据可以直接访问（不是非要使用指针访问）。
          如果你在编译之前精确的知道你需要分配数据的大小并且不是太大的时候，可以使用栈。
          当你程序启动时决定栈的容量上限。
      Heap：
          //堆上的变量必须要手动释放，不存在作用域的问题。数据可用 delete, delete[] 或者 free 来释放。
          相比在栈上分配内存要慢。
          通过程序按需分配。
          大量的分配和释放可造成内存碎片。
          在 C++ 中，在堆上创建数的据使用指针访问，用 new 或者 malloc 分配内存。
          如果申请的缓冲区过大的话，可能申请失败。
          在运行期间你不知道会需要多大的数据或者你需要分配大量的内存的时候，建议你使用堆。
          可能造成内存泄露。
3）
    1.对栈而言，栈中的新加数据项放在其他数据的顶部，移除时你也只能移除最顶部的数据（不能越位获取）。
    2.对堆而言，数据项位置没有固定的顺序。你可以以任何顺序插入和删除，因为他们没有“顶部”数据这一概念。

JVM怎样确定一个对象是否可以被回收？
    1.引用计数（Reference Counting）：给对象添加一个引用计数器，每有一个地方引用这个对象，计数器值加1，每有一个引用失效则减1。
    2.可达性分析(Reachability Analysis)：从GC Roots（每种具体实现对GC Roots有不同的定义）作为起点，向下搜索它们引用的对象，可以生成一棵引用树，
        树的节点视为可达对象，反之视为不可达。


JVM参数的含义 实例见实例分析

参数名称	含义	默认值
-Xms	初始堆大小	物理内存的1/64(<1GB)	默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.
-Xmx	最大堆大小	物理内存的1/4(<1GB)	默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制

-Xmn	年轻代大小(1.4or lator)
 	注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。
    整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.
    增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8

-XX:PermSize	设置持久代(perm gen)初始值	物理内存的1/64
-XX:MaxPermSize	设置持久代最大值	物理内存的1/4

-Xss	每个线程的栈大小	 	JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右
一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）
和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:"”-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了。
-XX:ThreadStackSize	Thread Stack Size	 	(0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.]


JAVA_OPTS="-Xms4g -Xmx4g -Xmn1024m -XX:PermSize=320M -XX:MaxPermSize=320m -XX:SurvivorRatio=6"

===============
1.JVM的内存区域划分：   https://www.cnblogs.com/dolphin0520/p/3613043.html
2.https://www.jianshu.com/p/c9ac99b87d56
3.http://www.codeceo.com/article/stack-and-heap.html
4.《深入理解Java虚拟机》周志明
5.https://blog.csdn.net/hu1991die/article/details/43052281