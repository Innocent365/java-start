1.名词解释：JavaEE: Edition,企业版，主要用于分布式的网络程序的开发
2.命名规则：类名大写，方法名和变量名小写（驼峰命名法），常量全部大写（用_分隔单词），
3.一个Java源文件至多有一个public修饰的类，而且名字必须与之相同
4.&和&&: &全部计算完、&&短路计算功能
5.常用JDK包：
	java.lang 不需导入
	java.io
	java.net 网络相关，url、urlConnection
	java.util 辅助：Collection、Map
	java.sql 数据库：Connection、Statement、ResultSet
6.递归解决的问题：
	a.数据定义是递归的， Fibonacci(斐波那契)函数；
	b.数据的解法需要回溯
	c.数据结构形式是递归，树的遍历，图的搜索
7.排序：插入（直接插入、希尔排序），交换排序（冒泡、快速），选择排序（直接选择、堆排序），归并排序、分配排序（箱排序、基数排序）
8.堆heap和栈stack：
	a.栈存放基本类型变量和对象引用，当超过作用域后被JVM自动释放，不纳入GC的管理范畴；
		堆存放new出来的对象和数组。
	b.堆可以动态地分配内存大小，生存期也不必事先告诉编译器，java的垃圾收集器会自动收走这些不再使用的数据。存在栈中的数据大小和生存期是事先确定的。
		栈的存取速度比堆块，仅次于直接位于CPU中的寄存器。堆是动态分配的内存，存取速度慢	。
	c.栈的数据可以共享，例如字面量3等，堆不可.		//20180514 ？？？
	d.栈是一种线性集合，其添加和删除元素的操作应在同一段完成，栈按照后进先出的方式进行处理；堆地址是不连续的，可随机访问。
	
	什么理解堆和栈：
		Java把内存分成两种，一种叫做栈内存，一种叫做堆内存。
		分别是什么数据结构？
			栈是一种后进先出性质的数据结构，就是后存放的先取，先存放的后取
			堆是一堆经过排序的树形数据结构，每个节点都有一个值。通常所说的堆结构，是指二叉堆，堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。
		为什么要分为堆和栈来存储数据？
			a.从软件设计的角度看，栈代表了处理逻辑，堆代表了数据
			b.堆和栈的分离，使得堆中的内容可以被多个栈共享。一方面这种共享提供了一种有效的数据交互方式（如共享内存），另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。
			c.栈因为运行时的需要，例如保存系统运行上下文，需要进行地址段的划分。因为栈只能向上增长，因此会限制栈存储内容的能力，而堆是可以根据需要动态增长的。
	JVM中的堆和栈
	　　JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。
		JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。
	JVM GC判断对象可以被回收的依据：
		对象没有被引用
		程序在作用域执行完毕、或在作用域发生异常
		程序执行了System.exit()
		程序被意外终止，例如进程被查杀
		
		
OOP
-------------------------------------
1.继承：单继承，在重写的方法里使用super关键字调父类的方法，重写时权限不能比父类的更严格
2.abstract class 和 interface：抽象类可以有自己的数据成员，也可以有非abstract的成员方法（赋予方法的默认行为）。
	interface可以继承interface，abstract可以实现interface
3.构造器Constructor不被继承，亦不能被重写 Override。经常被重载Overload
4.static：
	a.修饰成员变量；变量不属于对象而属于类，通过类名来引用，存储在方法区，而不是堆中
	b.修饰成员方法：其运行结果仅与输入的参数有关，直接用类名引用。提供“工厂方法”
	c.static块：类加载期间（ClassLoader）仅执行一次，用来加载静态资源。	
	d.修饰内部类
5.class A entends B{}
	A a = new A();	//执行顺序：B静态代码块->A静态代码块-> B非静态代码块->B构造器 ->A非静态代码块->A构造器
6.内部类：匿名内部类可以继承其他类或实现其他接口。
	内部类可以引用其所在类的内部成员，没有任何限制。
7.异常，检查异常和非检查异常。
	非检查异常（运行时异常，不可避免）：NullPoint、NumberFormat、ClassCast、ArrayIndexOutOfBounds、IllagalArgumentException
	检查异常：SQLException、IOException、ClassNotFoundException
	每当遇到一个try语句，异常的框架就放到堆栈上面，直到所有的try语句都完成。

8.transient关键字：
    将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。
        换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。
    transient使用小结：
        1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。
        2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。
        3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。
            注：静态变量的值为当前JVM中对应static变量的值，这个值是JVM中的，不是反序列化得出的
    被transient关键字修饰的变量真的不能被序列化吗？
        对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，
            若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。


堆和栈	
---------------------------------------
https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247484207&idx=1&sn=b01a78f563cc818364185a764b929402&chksm=ebd63c03dca1b5159bd687188ef9ecaec1604c694c2c8e7c3b932e41bc6017d34264c5336c05&scene=21#wechat_redirect	
