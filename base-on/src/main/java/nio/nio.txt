Java NIO 从 JDK1.4 引入，它提供了与标准 IO 完全不同的工作方式。

    NIO 包（java.nio.*）引入了四个关键的抽象数据类型，它们共同解决传统的 I/O 类中的一些问题。

        Buffer：它是包含数据且用于读写的线形表结构。其中还提供了一个特殊类用于内存映射文件的 I/O 操作。
        Channels：包含 socket，file 和 pipe 三种管道，它实际上是双向交流的通道。
        Selector：它将多元异步 I/O 操作集中到一个或多个线程中。

        //Charset：它提供 Unicode 字符串影射到字节序列以及逆影射的操作。  次要

jio与nio比较：
    数据的读写操作:
        标准的 IO 是基于字节流和字符流进行操作的，它不能前后移动流中的数据，
        而 NIO 是基于通道（Channel）和缓冲区（Buffer）进行操作的，数据总是从通道读取到缓冲区中，
        或者从缓冲区写入到通道中，需要时可以在缓冲区中前后移动所保存的数据。
    阻塞与非阻塞：
       标准 IO 的 Socket 编程中，套接字的某些操作可能会造成阻塞：
            accept()方法的调用可能会因为等待一个客户端连接而阻塞，
            read()方法也可能会因为没有数据可读而阻塞，
            write()方法在数据没有完全写入时也可能会发生阻塞，
          阻塞发生时，该线程被挂起，什么也干不了。
          多线程处理多个连接。每个线程拥有自己的栈空间并且占用一些 CPU 时间。

       NIO 则具有非阻塞的特性，可以通过对 channel 的阻塞行为的配置，实现非阻塞式的信道。
            在非阻塞情况下，线程在等待连接，写数据等（标准 IO 中的阻塞操作）的同时，也可以做其他事情，这便实现了线程的异步操作。

       非阻塞式网络 IO 的特点
           把整个过程切换成小的任务，通过任务间协作完成。
           由一个专门的线程来处理所有的 IO 事件，并负责分发。
           事件驱动机制：事件到的时候触发，而不是同步的去监视事件。
           线程通讯：线程之间通过 wait,notify 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的进程切换。

NIO和IO如何影响应用程序的设计:
    1.对NIO或IO类的API调用：
        因为并不是仅从一个InputStream逐字节读取，而是数据必须先读入缓冲区再处理
    2.数据处理：
        你怎么知道是否该缓冲区包含足够的数据可以处理呢，发现的方法只能查看缓冲区中的数据。
        其结果是，在你知道所有数据都在缓冲区里之前，你必须检查几次缓冲区的数据。
    3.用来处理数据的线程数:
        NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），
        但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。


nio主要原理及使用：
    selector 选择器:
        监听多个通道的事件（比如：连接打开，数据到达）,当有事件发生时，就会通知我们，传回一组SelectionKey,
        读取这些key，就可以获得我们刚刚注册的SocketChannel, 从这个Channel中读取数据，接着处理这些数据。

        selector 内部原理实际是在做一个对所注册的Channel的轮询访问，不断的轮询。


        因此，单个的线程可以监听多个数据通道，这也是非阻塞 IO 的核心。
        而在标准 IO 的 Socket 编程中，单个线程则只能在一个端口监听。




https://wiki.jikexueyuan.com/project/java-nio-zh/java-nio-non-blocking-server.html