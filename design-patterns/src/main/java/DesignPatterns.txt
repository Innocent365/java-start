设计模式可以分为三大类：
	创建型的设计模式:
		单例模式(Singleton)：确保有且只有一个对象被创建。 
		抽象工厂模式(Abstract Factory) ：允许客户创建对象的家族，而无需指定他们的具体类。 
		工厂方法模式(Factory Method) ：由子类决定要创建的具体类是哪一个。 
	行为设计模式：
		策略模式(Strategy) ：封装可以互换的行为，并使用委托来决定要使用哪一个。 
		状态模式(State) ：封装了基于状态的行为，并使用委托在行为之间切换。 
		观察者模式(Observer) ：让对象能够在状态改变时被通知。 
	结构型设计模式： 
		装饰者模式(Decorator) ：包装一个对象，以提供新的行为。 
		代理模式(Proxy) ：包装对象，以控制对此对象的访问。 
	
六大原则：
	1.开闭原则：对扩展开放，对修改关闭，实现热插拔的效果	
	2.依赖倒置原则：要依赖抽象，不要依赖具体类
		下面的指导方针，能避免在OO设计中违反依赖倒置原则：
			1.变量不可以持有具体类的引用
			2.不要让类派生自具体类
			3.不要覆盖基类中已实现的方法		//如果覆盖基类中已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享
	3.单一职责原则：类的变更的原因应该只有一个。
		除了类与接口之外，方法也同样需要使用单一职责原则，避免方法颗粒度太粗 
			类尽量做到单一原则，接口一定要做到单一原则
	4.里氏代换原则：只要父类能出现的地方子类就可以出现，替换为子类也不会产生任何错误和异常，但是反过来却不行，有子类的地方父类未必能适应 
		里氏替换原则为良好的继承定义了规范 
			1).子类必须完全实现父类的方法，如果子类不能完整的实现父类的方法，建议断开继承，采用依赖，聚集，组合等关系代替继承 
			2).子类可以有自己的个性 
			3).覆盖或实现父类方法时参数可以被放大 
			4).覆写或实现父类方法时输出结果可以被缩小
	5.接口隔离原则：建立单一接口，不要建立臃肿的接口 
		通过分散定义接口可以预防未来变更的扩散，提高系统灵活性和可维护性 
	6.迪米特法则：一个对象应该对其他对象有最少的了解 
		
	

1.策略模式：将变化的部分抽象成接口，定义实现类，在子类中对具体的行为设置不同的策略

2.观察者模式：订阅模式，消息通知。
	服务方，发行方：基本的 订阅/取消订阅，通知	继承Observable类
	观察者，订阅方：实现一个更新方法，服务方更新时，可通过此方法获取相应数据		实现Observer接口，重新update方法(Observable o, Object arg);
	
	不要依赖于观察者被通知的次序
	是一个类，而不是接口。java不支持多重继承，限制了 Observable 的复用潜力
	
3.状态模式：相比较策略模式更加主动的一种方式。
	相当于分身、影子，每个影子继承同一套功能接口（抽象出来需要多态的动作），分别实现各自的动作。
	主体包含了其分身，初始化的时候各个状态均指向主题本身。
	
	Context:    是一个类，它拥有一些内部状态
	State：  定义了一个所有具体状态的共同接口，任何状态都实现这相同的接口，这样，状态之间可以互换
	 策略模式是围绕可以互换的算法来创建成功业务的。
	 通过改变对象内部的状态来帮助对象控制自己的行为。
	 
4.装饰者模式，装饰者和被装饰者有共同的超类，可以用一个或多个装饰者共同装饰包装一个对象。
	装饰者在它的装饰者之前加上自己的行为，达到特定的目的。
	装饰者保存了一个被装饰者的引用。 
5.单例模式：
	有很多对象我们只需要一个，例如：线程池（threadPool），缓存（cache）、对话框、处理偏好设置、注册表（registry）、日志对象、充当打印机、显卡等设备的驱动程序对象
6.工厂模式：
	一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。
	定义了一系列的标准方法，由各个实现类自己去实现具体的工厂方法。
7.代理模式：
	为另一个对象提供一个替身或占位符以控制对这个对象的访问。
	远程代理：用作另一个JVM上对象的本地代表，控制访问远程对象，			
	虚拟代理：用作创建开销大的对象的代表，控制访问创建开销大的资源，	控制对开销大的资源的访问
	保护代理：基于权限控制对资源的访问									动态代理
	