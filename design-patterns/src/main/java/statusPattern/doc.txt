状态模式：
策略模式和状态模式是双胞胎：
    策略模式是围绕可以互换的算法来创建成功业务的。
    然而，状态是更崇高的路，它通过改变对象内部的状态来帮助对象控制自己的行为。
    它常常告诉它的对象客户跟着我念：我很棒，我很聪明，我最优秀了……“”

    状态模式中，我们将一群行为封装在状态对象中，context的行为随时可以委托到那些状态对象中的一个。
        随着时间的流逝，当前状态在状态对象集合中游走改变，以反映出context内部的状态。
        客户对于状态对象了解不多。
    策略模式中，客户通常主动指定Context所要组合的策略对象是哪一个。

    把状态模式想成是不用在context中放置很多条件判断的替代方案。
        通过将行为包装进状态对象中，可以在context内简单地改变状态对象来改变context行为。

定义：
    现在我们要把一个状态的所有行为放在一个类中。这样一来我们将行为局部化了，并使得事情更容易改变和理解。

1.将每个状态的行为局部化到它自己的类中。
2.将容易产生问题的if语句删除，以方便日后的维护。
3.让每一个状态“对修改关闭”， 让糖果机“对扩展开放”，因为可以加入新的状态类。
4.创建一个新的代码基和类结构。

状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

结构：
                   NoQuarter
                   HasQuarter
    糖果机 ->      Sold
                   SoldOut

    Context:    是一个类，它拥有一些内部状态（糖果机）
    State：  定义了一个所有具体状态的共同接口，任何状态都实现这相同的接口，这样，状态之间可以互换
        -> ConcreteStateA 用来处理来自Context的请求。每一个ConcreteState都提供了它自己对于请求的实现。
        -> ConcreteStateB 所以，当Context状态改变时其行为也跟着改变。
        ConcreteStateA: stateMachine.setState(stateMachine.getConcreteStateB());
    state handle(): 不管什么时候，只要有人调用Context的request方法。就会被委托到状态来进行处理。

问答：
    1.Context 总是决定接下来的状态是什么吗?
        不总是如此，Context也可以决定状态转换的流向。
        一般来讲，当转换是固定的时候，就放在Context中；当转换是更动态的时候，就会放在状态类中。
        将状态转换放在状态类中的缺点是：状态类之间产生了依赖。
    2.客户会直接和状态交互吗？
        不会，全盘了解状态是Context的工作，客户根本不理解。
    3.假如Context有很多实例，可以共享状态吗？
        可以，而且很常见。但前提是，需要把每个状态指定到静态的实例变量中。
    4.使用状态模式似乎总是增加我们设计中类的数目，新版本比旧版本多出很多类。
        是的，这就是代价。为以后维护方便所付出的代价。
    5.状态State是一个抽象类，为什么不是使用接口？
        如果没有共同的功能可以放进抽象类中，就会使用接口。

自己的一点理解:
    一个状态可以理解为一个主体的分身，主体对外暴露的所有方法， 不同的分身选择性的重写。
    固定的行为方法放在主体里，由主体直接执行，不同状态情况不固定的方法，主体调用分身执行其对应的动作。
    主体包含所有自己的分身属性，并提供初始化和提供get和set方法，供分身之间转换相互切换。
    所有分身继承同一套功能接口（抽象出来需要多态的动作），分别实现各自的动作。

