代理：控制和管理访问。
JVM提供的远程代理方法：RMI, 通过网络远程访问代理里的JVM内存对象。
远程方法调用如何发生：
    1.客户对象调用客户辅助对象的doBigThing()方法;
    2.客户辅助对象(代理)打包调用信息（变量、方法名称等），然后通过网络将它发送给服务器辅助对象。
    3.服务器辅助对象把来自客户辅助对象的信息解包，找出被调用的方法（以及在哪个对象内），调用真正的服务对象上的真正方法。
    4.服务对象上被调用的方法返回结果。
    5.服务辅助对象打包调用的返回信息，发送给客户端。
    6.客户端辅助对象把返回值解包，返回给客户对象。
RMI（Terminology）提供了客户辅助对象stub（桩）和服务辅助对象skeleton（骨架），你不必亲自写任何网络或I/O代码。

    Client  -> Proxy -> RealSubject

定义：
    代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。
代理控制访问的方式：
    远程代理：用作另一个JVM上对象的本地代表，控制访问远程对象
    虚拟代理：用作创建开销大的对象的代表，控制访问创建开销大的资源，对象创建后，代理就会将请求直接委托给对象。
    保护代理：基于权限控制对资源的访问


问题：
    1.远程服务器和虚拟服务器差异看起来很大，他们真的是一个模式吗？
        真实的世界里，代理模式有很多变体，这些变体都有共通点：都会将客户对主题（Subject）施加的方法调用拦截下来。
        这种间接的级别让我们可以做很多事，包括将请求分发到远程主题，或创建开销大的对象提供代表，或者提供某些级别的保护，这种保护能决定哪些客户能调用哪些方法。
    2.imageProxy看起来好像是装饰者（Decorator）：都是用一个对象把另一个包起来，然后把调用委托给ImageIcon？
        看起来一样，但其实二者的目的是不一样的。装饰者为对象增加行为，而代理是控制对象的访问。
        imageProxy是如何控制ImageIcon呢？
        代理将客户从ImageIcon解耦了，如果它们之间没有解耦，客户就必须等到每幅图像都被取回，然后才能把它绘制在界面上。
        代理控制ImageIcon的访问，以便在图像完全创建之前提供屏幕上的代表。
    3.如何让客户使用代理，而不是真正的对象？
        一个常用的技巧是提供一个工厂，实例化并返回主题。在工厂内，我们可以用代理包装主题再返回。
    4.有没有办法知道某个类是不是代理类呢？
        代理类有个静态方法，isProxyClass()。此外，代理类还是实现某些特定的接口。

Java动态代理技术：
    Java在java.lang.reflect包中有自己的代理支持，利用这个包可以在运行时动态的创建一个代理类，实现一个或多个接口，
    并将方法的调用转发到你所指定的类。
    代理类是在运行时创建。代码开始执行时，还没有proxy类，根据需要从你传入的接口集中创建的。
    Proxy本身是利用静态的Proxy.newProxyInstance()方法在运行时动态地创建的。




